{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Tutorials","text":"<p>This temperary sites holds the tutorials for the <code>MOSCAL2.0</code> program, an pacakge for studying open quantum system. The this site is intended for Dr. Wenjie Dou's group members. </p> <p>Credit: this site is built by <code>mkdocs</code>, the official site is here.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/","title":"MOSCAL2.0 Hands on example","text":""},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/#exploring-the-spin-boson-model-with-moscal20","title":"Exploring the Spin-Boson Model with <code>MOSCAL2.0</code>","text":"<p>This guide aims to provide a step-by-step walkthrough of utilizing the <code>c++</code> binary program in <code>MOSCAL2.0</code> to apply the <code>DEOM</code> formalism in studying the spin-boson model. To provide an overview:</p> <ul> <li>Prerequisites: We'll first outline the prerequisites necessary for you to successfully follow this tutorial.</li> <li>Understanding the Spin-Boson Model: We'll delve into the fundamental concepts behind the spin-boson model to lay the groundwork for our exploration.</li> <li><code>MOSCAL2.0</code> Workflow: Explaining how <code>MOSCAL2.0</code> harnesses its <code>python</code> part to generate input for the <code>c++</code> binaries used in the spin-boson model analysis.</li> <li>Generating Spin-Boson Model Inputs: We'll guide you through the process of generating inputs tailored for the spin-boson model using <code>MOSCAL2.0</code>.</li> </ul> <p>This walkthrough will equip you with the necessary understanding and tools to explore and analyze the spin-boson model using <code>MOSCAL2.0</code> effectively.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/#prerequisites-bose_linear_2out","title":"Prerequisites: <code>bose_linear_2.out</code>","text":"<p>Before diving into the hands-on experience with the spin-boson model in <code>MOSCAL2.0</code>, it's essential to ensure that you have successfully compiled the package following the installation guide. </p> <p>Additionally, make sure you have obtained the specific binary, <code>bose_linear_2.out</code>, which corresponds to the spin-boson model within the <code>MOSCAL2.0</code> package.</p> <p>Finally, you shall install the official <code>python</code> module.</p> <p>If you have any problems, please refer to the installation guide.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/#understanding-the-spin-boson-model","title":"Understanding the Spin-Boson Model","text":"<p>The spin-boson model serves as a fundamental framework in quantum physics, describing the interaction between a quantum system (often representing a 'spin') and a surrounding environment (the 'bath'). Such interactions can be represented by Hamiltonian $$ H = H_\\text{s} + H_\\text{b} + H_\\text{sb}. $$ In this model, the system Hamiltonian is a general two-state Hamiltonian, i.e., a 2-by-2 matrix. The bath are bosonic degrees of freedom,  $$ H_\\text{b} = \\frac{1}{2} \\sum_j \\frac{\\omega_j}{2}(p_j^2 + q_j^2), $$ where \\(q_j\\) and \\(p_j\\) are the position and momentum operators for \\(j\\)-th oscillator, whose frequency is \\(\\omega_j\\) (note that we have set \\(\\hbar=1\\)).</p> <p>In the vacuum, the isolated two-state system (the spin) and the bath oscillators are exactly solvable. Whereas, the interesting physics arise when these two system have interaction. </p> <p>We will consider the simplest interaction possible -- the linear interaction:  $$ H_\\text{sb} = Q_\\text{s} x_\\text{B}, \\quad x_\\text{B} = \\sum_j c_j q_j, $$ where we see a system mode, \\(Q_\\text{s}\\), which is a 2-by-2 matrix, interacts with a collective phonon mode \\(x_\\text{B}\\). Phonon mode \\(x_\\text{B}\\) is a linear combination of all the bath operators. Since we have a linear combination of ten's of thousands of oscillators (imagine a solid-state material), the collective mode \\(x_\\text{B}\\) corresponds to a spectral density defined by the following equation $$ J(\\omega) = \\sum_j \\frac{c_j}{2} \\delta(\\omega - \\omega_j). $$ In practice, experimentalists can characterize \\(x_\\text{B}\\) by measuring the phonon spectra. But as theory people, we primarily use analytic spectral function to make our life easier. In particular, the Drude-Lorentz spectral function $$ J(\\omega) = \\frac{2\\lambda\\gamma\\omega}{\\omega^2 + \\gamma^2} $$ is the simplest one we can use. Here in the Drude spectral function:</p> <ul> <li>\\(\\lambda\\) characterizes the system-bath interaction strength</li> <li>\\(\\gamma\\) characterizes the \"peak\" position </li> </ul> <p>(Feel free to use python <code>matplotlib</code> package to visualize this spectarl function.)</p> <p>In conclusion, the spin-boson model characterize the linear coupling between a 2-state system and a very large bath of harmnic oscillators. The detail of the interaction between the discrete system and the continuum bath is fully characterized by the spectral function \\(J(\\omega)\\).</p> <p>The goal of open quantum dynamics simultion is to know, if we have a initial density matrix \\(\\rho_\\text{s}(t=0)\\) for the system, what will this reduced density matrix for \\(t&gt;0\\).</p> <p>Info</p> <p>From this very simple description of the spin-boson model, can you see why it's required for you to compile <code>bose_linear_2.out</code>.</p> <p>Despite the goal of this tutorial is to tell you how to numerically simulate the spin-boson model using the DEOM formalism.  It is important to know that dynamics for such model is exactly solvable on paper. If you feel interested (, and have time of course), you can check Chapter 12 of Chemical Dynamics in Condensed Phases by Abraham Nitzan.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/#the-workflow-for-the-moscal20-package","title":"The Workflow for the <code>MOSCAL2.0</code> package:","text":"<p>The <code>MOSCAL2.0</code> package streamlines the process of generating inputs for simulations by following a structured workflow:</p> <ol> <li> <p>Utilizing Official Python Scripts: <code>MOSCAL2.0</code> provides official Python scripts designed to facilitate the generation of inputs required for simulations. These scripts are crafted to simplify the input creation process by allowing users to define parameters, configurations, and specifications in a structured manner. These scripts generate the necessary input data in <code>json</code> format, encapsulating the simulation details.</p> </li> <li> <p>Creating the <code>input.json</code> File: Upon executing the official Python scripts, the result is the creation of an <code>input.json</code> file. This file contains the formatted input data, encapsulating the specifics necessary for the subsequent <code>MOSCAL2.0</code> simulations. The <code>json</code> format ensures readability, portability, and ease of use for the generated input information.</p> </li> <li> <p>Invoking <code>MOSCAL2.0</code> Binary Execution: With the <code>input.json</code> file prepared, the next step involves invoking the relevant <code>MOSCAL2.0</code> binary files. These binaries, residing within the same directory as the <code>input.json</code> file, are executed to conduct simulations or analyses based on the provided input parameters. The binaries interpret the information within <code>input.json</code>, enabling the initiation of simulations tailored to the defined configurations.</p> </li> </ol>"},{"location":"MOSCAL2.0/MOSCAL2.0_Hands_on_example/#concrete-example","title":"Concrete example","text":"<p>In this example, we will simulate dynamics the following system Hamiltonian $$ H_\\text{s} = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\ \\end{bmatrix}, $$ with system bath interaction $$ H_\\text{sb} = Q x_\\text{B} = \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\ \\end{bmatrix} x_\\text{B}.$$ The spectral function is $$ J(\\omega) = \\frac{2\\lambda\\gamma\\omega}{\\omega^2 + \\gamma^2}, \\lambda = \\gamma = 1.0, $$ at bath temperature \\(k_\\text{B} T = 1.0\\) (i.e., \\(\\beta = 1.0\\)).</p> <p>First, you write your <code>python</code> script <code>spin-boson.py</code> to generate the input for the <code>bose_linear_2.out</code> binary.</p> <pre><code># spin-boson.py\n\nimport numpy as np\nimport sympy as sp\n\nimport json\nfrom deom import convert, decompose_spe, complex_2_json, init_qmd\n\n\ndef decompose_drude_spectral_function(npsd: int, beta: float, gamma: float=1.0, lambd: float=1.0):\n    w_sp, lambd_sp, gamma_sp, beta_sp = sp.symbols(r\"\\omega, \\lambda, \\gamma, \\beta\", real=True)\n    spe_vib_sp = 2 * lambd_sp * gamma_sp / (gamma_sp - sp.I * w_sp)\n    sp_para_dict = {lambd_sp: lambd, gamma_sp: gamma}\n    condition_dict = {}\n    para_dict = {'beta': beta}\n\n    etal, etar, etaa, expn = decompose_spe(spe_vib_sp, w_sp, sp_para_dict, para_dict,\n                                           condition_dict, npsd)\n\n    return etal, etar, etaa, expn\n\nif __name__ == \"__main__\":\n    #------------------------------------------------------------------------------#\n    # The simulation parameters\n    #------------------------------------------------------------------------------#\n\n    # These parameters controls the dynamics\n    dt = 0.01\n    tf = 25\n\n    # These parameters controls the accuracy of DEOM\n    npsd = 2       # number of exponential decays to decompose the correlation function\n    lmax = 50      # maximum tiers for the dissipaton density operators\n    ferr = 1e-12   # the filtering tolerence (ignore the very small numbers)\n    nmax = 1000000 # maximum number of dissipaton density operators\n\n    # These parameters controls the bath, bath mode, and spectral function\n    beta  = 1.0   # The inverse temperature 1/ (k_B T)\n    gamma = 1.0   # gamma in drude spectral\n    lambd = 1.0   # lambda in drude spectral\n    nmod  = 1     # number of collective modes x_B to consider\n\n    #------------------------------------------------------------------------------#\n    # Hamiltonian H, system mode Q, and initial density matrix rho\n    #------------------------------------------------------------------------------#\n    rho0 = np.zeros((2, 2), dtype=complex)\n    rho0[0, 0] = 1\n    rho0[1, 1] = 0 # rho0 is initilize as |0&gt;&lt;0|\n\n    hams = np.zeros((2, 2), dtype=complex)\n    hams[0, 0] = 1\n    hams[0, 1] = 1\n    hams[1, 0] = 1\n    hams[1, 1] = -1 # This is the two-state system Hamiltonian\n\n    qmds = np.zeros((nmod, 2, 2), dtype=complex)\n    qmds[0, 0, 1] = 1\n    qmds[0, 1, 0] = 1 # This is the interacting system mode, here we consider only one mode; essentially the mode is the pauli matrix sigma_x\n\n    nsys = 2\n\n    #------------------------------------------------------------------------------#\n    # Decompose the spectral function (more precisely the correlation function)\n    #------------------------------------------------------------------------------#\n    etal, etar, etaa, expn = decompose_drude_spectral_function(npsd, beta, gamma, lambd)\n    mode = np.zeros_like(expn, dtype=int)\n\n    json_init = {\n         \"nmax\": nmax,\n         \"lmax\": lmax,\n         \"ferr\": ferr,\n         \"filter\": True,\n         \"nind\": len(expn),\n         \"nmod\": nmod,\n         \"equilibrium\": {\n             \"sc2\": False,\n             \"dt-method\": True,\n             \"ti\": 0,\n             \"tf\": 25,\n             \"dt\": dt,\n             \"backup\": True,\n         },\n         \"expn\": complex_2_json(expn),\n         \"ham1\": complex_2_json(hams),\n         \"coef_abs\": complex_2_json(etaa),\n         \"read_rho0\": True,\n         \"rho0\": complex_2_json(rho0),\n     }\n\n    init_qmd(json_init, qmds, qmds, mode, nsys, etaa, etal, etar)\n    with open('input.json', 'w') as f:\n        json.dump(json_init, f, indent=2, default=convert)\n</code></pre> <p>Run this script,</p> <pre><code>python spin-boson.py\n</code></pre> <p>then you shall see <code>input.json</code> in the current directory.</p> <p>Finally, you can run your <code>MOSCAL</code> program by executing these commands in your command line: <pre><code>MOSCAL_BIN=\"/path/to/bose_linear_2.out\"\n\n${MOSCAL_BIN} # make sure you have input.json in your working directory\n</code></pre> (Alternatively, you can write a shell script <code>run_spin_boson.sh</code> to do this.)</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/","title":"Installation guide for MOSCAL2.0","text":"<p><code>MOSCAL2.0</code> is a very useful software to study open quantun systems. The software is developed by one of our collaborators, Dr. YiJing Yan's group. The project is now open on the USTC gitlab page. </p> <p>TLDR</p> <p>The following is a simple description of the <code>MOSCAL2.0</code> pacakge, if you only want to compile the library, you can skip this and just go to the minimal build section.</p> <p>The <code>MOSCAL2.0</code> program is written in <code>c++</code> and a user interface written in <code>python</code>. The design idea is to use simple python scripts to  generate inputs for the <code>c++</code> library. Therefore, without knowing the <code>c++</code> internals of <code>MOSCAL2.0</code>, the user can just write python scripts and  simulate open quantum systems.</p> <p>The <code>MOSCAL2.0</code> has the following technical advantages comparing to other implementations, for example <code>HierarchicalEOM.jl</code>:</p> <ul> <li><code>MOSCAL2.0</code> has a clean theory: the library is built based on the idea of Dissipatons, a quasi-particle describing system-bath interactions. In this idea, the auxiliary density operators (ADOs) are regarded as different degrees of excitations of the non-interacting system, i.e., the dissipaton density operators (DDOs).  Such theoretical designs help our collaborator derive useful algebras to efficiently manipulate DDOs, more importantly derive new applications such as quadratic-system bath coupling easily.</li> <li><code>MOSCAL2.0</code> is Efficient: the library is written <code>c++</code>, with powerful parallelization and filtering schemes:<ul> <li>Many operations on the DDOs are written in parallel algorithms, and these algorithms are carefully designed to be thread-safe.</li> <li>Instead of make a hard truncation over the hierarchical tiers and use a fixed propagation matrix, <code>MOSCAL2.0</code> applies a dynamic filtering scheme. Particularly, the user will apply a soft hierarchical cutoff. As a result, all the possible DDOs within the maximum hierarchical depth can be considered if they are numerically significant enough. The filtering tolerance here is input by the user. With filtering, it is easy to choose a very deep hierarchical depth, with way less computation cost by taking advantage of the sparse nature of the HEOM propagator.</li> </ul> </li> </ul> <p>To harness efficiency of the <code>MOSCAL2.0</code> package, let us then go through the process of build the <code>c++</code> binaries. </p> <p>NOTE: If you are experienced using the <code>Docker</code>, you should follow the official instruction on <code>MOSCAL2.0</code> site. If you intend to build the <code>c++</code> library from scratch, follow the instructions given below.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#build-the-c-library-on-you-macos-machine","title":"Build the <code>c++</code> library on you <code>MacOS</code> machine","text":""},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#minimal-build","title":"Minimal build","text":"<p>First, you clone the package on your local machine. <pre><code>git clone https://git.lug.ustc.edu.cn/czh123/moscal2.0 \n</code></pre></p> <p>Then, you need to install the necessary dependencies of <code>MOSCAL2.0</code>. - The parallelization of <code>MOSCAL2.0</code> depends on <code>OpenMP</code>. - The easy building of the <code>MOSCAL2.0</code> depends on <code>cmake</code>. Luckily, our group member has a <code>MACOS</code> workstation. Installing these dependent packages can be simplified by <code>homebrew</code>.</p> <pre><code># If you don't already have homebrew installed, \n# you can go to https://brew.sh to learn about it and install homebrew on your computer\n# after brew is on you machine, just execute \nbrew install libomp\necho \"export OpenMP_ROOT=$(brew --prefix)/opt/libomp\" &gt;&gt; ~/.zshrc # This ensures cmake finds OpenMP\nbrew install cmake\n</code></pre> <p>After all the necessary tools (<code>OpenMP</code> and <code>cmake</code>) have been installed, we can start the building process. The first thing you should do is traversing to the <code>/path/to/moscal2.0/code</code> directory.</p> <pre><code>cd /path/to/moscal2.0/code\n</code></pre> <p>Note</p> <p>The current version of <code>moscal2.0</code> code has a redundant line, which spoils the minimal build.  We are sorry that you have to comment out one of the line in file <code>/path/to/moscal2.0/code/include/headfile.hpp</code> <pre><code># open the file /path/to/moscal2.0/code/include/headfile.hpp\n# go to the line that says \"include &lt;openssl/md5.h&gt;\"\n# then comment this line out by `//`\n# hint: this line was the 14-th line in headfile.hpp (for Commit bc62005f);\n</code></pre> If you have done the comment, you shall have <pre><code>// include &lt;openssl/md5.h&gt;\n</code></pre> If you cannot find this line, or see this line already commented. That mean this redundancy is patched.</p> <p>Then, you will need to create a new file in the <code>code</code> directory named <code>CMakeLists.txt</code>. Then you copy the following <code>CMakeLists.txt</code> content to your local file.  <pre><code>cmake_minimum_required(VERSION 3.12)\nproject(MOSCAL2.0 LANGUAGES CXX)\nset(CMAKE_BUILD_TYPE RLEASE)\nset(CMAKE_CXX_STANDARD 17)   # use modern c++ standard\n\n# The compiler flags for optimization and compile time options\nadd_compile_options(-O3)              # Generic maximum code optimization\nadd_compile_options(-ftree-vectorize) # SIMD vectorize the loops\nadd_compile_options(-funroll-loops)   # explicit optimize the loops\nadd_compile_options(-fPIE)            # make code run everywhere\nadd_compile_options(-Wall -Wextra -Wpedantic) # Enable warning\n\ninclude(GNUInstallDirs) # Enable cmake to find the system installations\n\n# Find openssl\n# find_package(OpenSSL REQUIRED)\n\n# Find libomp for parallelization\nif (APPLE)\n    # execute shell command OpenMP_ROOT=$(brew --prefix)/opt/libomp\n    find_program(HOMEBREW_EXECUTABLE brew)\n    if (HOMEBREW_EXECUTABLE)\n        execute_process(\n            COMMAND ${HOMEBREW_EXECUTABLE} --prefix\n            OUTPUT_VARIABLE BREW_PREFIX\n            OUTPUT_STRIP_TRAILING_WHITESPACE\n        )\n        set(OpenMP_ROOT \"${BREW_PREFIX}/opt/libomp\" CACHE PATH \"Path to libomp\")\n    endif()\nendif()\nfind_package(OpenMP)\n\nif(OpenMP_FOUND)\n    message(STATUS \"OpenMP found\")\nelse()\n    if (APPLE)\n        if(CMAKE_SYSTEM_PROCESSOR MATCHES \"x86_64\") # Intel Mac\n            # Set default paths for libomp\n            set(ENV{LDFLAGS} \"-L/usr/local/opt/libomp/lib\")\n            set(ENV{CPPFLAGS} \"-I/usr/local/opt/libomp/include\")\n        elseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"arm64\") # Apple Silicon\n            # Set default paths for arm64 Macs\n            set(ENV{LDFLAGS} \"-L/opt/homebrew/opt/libomp/lib\")\n            set(ENV{CPPFLAGS} \"-I/opt/homebrew/opt/libomp/include\")\n        endif()\n    else()\n        # set the default path for any unix machine\n        set(ENV{LDFLAGS} \"-L/usr/local/opt/libomp/lib\")\n        set(ENV{CPPFLAGS} \"-I/usr/local/opt/libomp/include\")\n    endif()\n\n    message(WARNING \"OpenMP not found, using default paths instead\")\n    # Set the LDFLAGS and CPPFLAGS manually\n    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} $ENV{LDFLAGS} $ENV{CPPFLAGS}\")\nendif()\n\n# do not try to find pacakge for Eigen3, just use shipped one\n# do not try to find pacakge for nlohmann, just use the shipped one\n\n# find folly to harness the parallelization algorithms\nfind_package(Folly)\nif(Folly_FOUND)\n    message(STATUS \"Found Folly: \")\n    message(STATUS \"Include directory: ${FOLLY_INCLUDE_DIR}\")\n    message(STATUS \"Library: ${FOLLY_LIBRARIES}\")\n\n    # Look for gflags\n    find_package(gflags)\n\n    if(gflags_FOUND)\n        message(STATUS \"Found gflags:\")\n        message(STATUS \"Include directory: ${GFLAGS_INCLUDE_DIRS}\")\n        message(STATUS \"Libraries: ${GFLAGS_LIBRARIES}\")\n    else()\n        message(WARNING \"gflags not found.\")\n    endif()\nelse()\n    message(WARNING \"Folly not found. The built library will be un-parallelizable.\")\nendif()\n\n# now make all the subdirectories visible to cmake\ninclude_directories(\n    ${CMAKE_CURRENT_SOURCE_DIR}/include\n    ${CMAKE_CURRENT_SOURCE_DIR}/include/low_level # for low-level implementations of DDO EOMs\n    ${CMAKE_CURRENT_SOURCE_DIR}/include/aux       # for operations on DDOs or Aux Density operators\n)\n\n### now define a function to build specifc applications\n# Define a function to build the main_threads_omp_equ_corr.cpp file\nfunction(build_population BINARY_NAME)\n    add_executable(${BINARY_NAME} main_threads_omp_equ_corr.cpp)\n\n    target_compile_definitions(${BINARY_NAME} PRIVATE ${ARGN})\n\n    # target_link_libraries(${BINARY_NAME} PRIVATE OpenSSL::SSL)\n    if (OpenMP_FOUND)\n        # use OpenMP::OpenMP_CXX\n        target_link_libraries(${BINARY_NAME} PRIVATE OpenMP::OpenMP_CXX)\n    endif()\n\n    if (Folly_FOUND)\n    target_link_libraries(${BINARY_NAME} PRIVATE\n        ${GFLAGS_LIBRARIES}\n        Folly::folly\n    )\n    else()\n        target_compile_definitions(${BINARY_NAME} PRIVATE STD)\n        message(WARNING \"Folly not found. Use the STD macro. This build will not be parallelized since you don't have Folly.\")\n    endif()\n\nendfunction()\n\nbuild_population(bose_linear_2.out NSYS=2 BOSE_LINEAR NORMAL)       # 2x2 system coupled with a linear boson environment\nbuild_population(bose_quad_2.out NSYS=2 BOSE_QUAD NORMAL)           # 2x2 system coupled with a quadratic boson environment\nbuild_population(bose_linear.out BOSE_LINEAR NORMAL)                # a general system (meaning the system matrix is any nxn matrix) coupled with a linear boson environment\nbuild_population(bose_quad.out BOSE_QUAD NORMAL)                    # a general system (meaning the system matrix is any nxn matrix) coupled with a quadratic boson environment\n</code></pre> This configuration file will precisely tell the <code>cmake</code> program about the detailed recipes for building <code>MOSCAL2.0</code>. </p> <p>Finally, we can build the <code>MOSCAL2.0</code> easily  <pre><code># please create CMakeLists.txt in /path/to/moscal2.0/code \nmkdir build\ncd build\ncmake ..\nmake\n</code></pre> If everything runs correctly, you shall see the <code>cmake</code> program handles the building process that many greens lines, (and some pinks for error).  If you didn't see any red alerts and error messages, you can go out and check that you get new files <code>bose_linear.out</code>, <code>bose_linear_2.out</code>, <code>bose_quad.out</code> and <code>bose_quad_2.out</code> in your <code>build</code> directory.  These, are indeed the executables you need to run the open quantum simulation examples. On how to use these binaries, see the python examples in <code>/path/to/moscal2.0/test</code>. All the above, concludes the building process for the </p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#extra-efficiency-from-facebooks-folly-library","title":"Extra efficiency from Facebook's folly library.","text":"<p>Bug</p> <p>Please stop reading for now! The <code>folly</code> part now has some bug. We cannot use the full version of <code>MOSCAL2.0</code> yet!</p> <p>Now if your feel really geeky and greedy, that you feel an urge to speed up your calculations even more, you keep reading from here. In fact, not all the components in <code>MOSCAL2.0</code> are parallelized if you follow the minimalistic build in the last section. Particularly, the filtering algorithm will be serial. For geeks, this is because the parallel filtering algorithm of <code>MOSCAL2.0</code> depends on a package called <code>folly</code>. And if </p> <p>TLDR; you will have to install the <code>folly</code> library to unleash the full power of <code>MOSCAL2.0</code>. Luckily, if you have <code>homebrew</code>, this will be quite easy. <pre><code>brew install folly\n# after properly install the folly library, go on rebuild the `MOSCAL2.0` program.\n# cmake is smart enough to see if folly is installed.\ncd /path/to/moscal2.0/code/build\ncmake ..\nmake\n</code></pre></p> <p>If <code>folly</code> is correctly installed, you shall have a fully parallelized distribution of <code>MOSCAL2.0</code>.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#build-macros-control-what-module-you-are-building","title":"Build macros: control what module you are building","text":"<p>Following the minimal build example, you obtain four binary files:</p> <ul> <li><code>bose_linear_2.out</code>: This binary is for the open quantum dynamics of a 2*2 quantum system interacting with a bosonic bath.</li> <li><code>bose_quadratic_2.out</code>: This binary is for the open quantum dynamics of a 2*2 quantum system interacting with a bosonic bath.</li> <li><code>bose_linear.out</code>: This binary is for the open quantum dynamics of an arbitrary N*N quantum system interacting with a bosonic bath. </li> <li><code>bose_quadratic.out</code>: This binary is for the open quantum dynamics of an arbitrary N*N quantum system interacting with a bosonic bath. </li> </ul> <p>What if you want to study some other system bath interactions? For example, a fermionic system? </p> <p>To build other <code>MOSCAL2.0</code> modules, a basic understanding of macros becomes essential. In essence, macros serve as a means of communication with the compiler. In the context of <code>MOSCAL2.0</code>, macros are crucial for specifying the desired program configurations. For instance, if you aim to study a linear system-bath interaction involving a bosonic bath, you'd communicate this intent to the compiler using the <code>BOSE_LINEAR</code> macro. Additionally, when dealing with smaller systems, like a 2x2 setup, employing the <code>NSYS=2</code> macro informs the compiler to generate an optimized program leveraging stack allocation. </p> <p>Warning</p> <p>Stack allocation is beneficial for small matrices, typically those with dimensions up to 4x4. It optimizes memory management and improves performance. However, for larger systems exceeding dimension of 4, it's advisable to avoid specifying the <code>NSYS</code> macro to prevent potential memory issues associated with stack limitations.</p> <p>In practical application, the <code>CMakeLists.txt</code> file provides a convenient <code>cmake</code> function called <code>build_population</code> for obtaining the desired binaries. You can utilize this function by specifying the necessary macros. The format is as follows: <pre><code>build_population(your_binary_name MACRO1 MACRO2 ...)\n</code></pre> For instance, suppose you aim to compile a 4x4 system coupled with a linear fermionic system-bath coupling program. Simply include this line in your <code>CMakeLists.txt</code> <pre><code>build_population(fermi_linear_4.out NSYS=4 FERMI_LINEAR NORMAL)\n</code></pre></p> <p>For your references, here is a table of macros used by <code>MOSCAL2.0</code></p> Macro Description <code>BOSE_LINEAR</code> Specifies a linear system-bath interaction with bosons. <code>BOSE_QUAD</code> Specifies a quadratic system-bath interaction with bosons. <code>FERMI_LINEAR</code> Specifies a linear system-bath interaction with fermions. <code>FERMI_QUAD</code> Specifies a quadratic system-bath interaction with fermions. <code>SPARSE</code> Enforces the use of sparse matrices, ideal for large, less dense systems. <code>NORMAL</code> Controls an unspecified filtering algorithm (default setting). <code>NSYS=4</code> Informs the compiler to optimize for a system of size 4,  potentially improving computations for this specific size. <p>The table above showcases the most commonly used macros within <code>MOSCAL2.0</code>. While there are additional macros that unlock further modules in the <code>MOSCAL2.0</code> package, they are beyond the scope of this tutorial. For more comprehensive information, please refer to the official documentation.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#build-the-c-library-on-the-westlake-university-hpc","title":"Build the <code>c++</code> library on the Westlake University HPC.","text":"<p>TODO: This section is under construction.</p>"},{"location":"MOSCAL2.0/MOSCAL2.0_Installation_Guide/#install-the-official-python-module","title":"Install the official <code>python</code> module","text":"<p>Note</p> <p>We regret to inform you that the official <code>python</code> module for <code>MOSCAL2.0</code> does not provide a <code>setup.py</code> for installation.</p> <p>While the installation of the python module is not mandatory, it significantly streamlines usage. Although there's the option to manually copy the module's source code to a desired location, opting for installation greatly simplifies the process and ensures ease of use. We recommend considering installation for a more seamless experience in utilizing the python module functionalities within <code>MOSCAL2.0</code>.</p> <p>First, please locate the directory of the python module <code>deom</code>. You will find it in <code>/path/to/moscal2.0/test/deom</code>.</p> <p>Second, please choose your preferred location for this python module. Feel free to choose any location on your computer.  Then copy the <code>deom</code> directory here. <pre><code>mkdir deom # choose any location\ncp -r /path/to/moscal2.0/test/deom/ deom\n</code></pre></p> <p>Third, create a <code>setup.py</code> file in this directory <pre><code># setup.py\n\n import os\n from setuptools import setup, find_packages\n\n def read(fname):\n     return open(os.path.join(os.path.dirname(__file__), fname)).read()\n\n # Read the requirements from requirements.txt file\n with open('requirements.txt') as f:\n     requirements = f.read().splitlines()\n\n setup(\n     name=\"deom\",\n     description=\"Python interface to the c++ open quantum system program: DEOM\",\n     author=\"czh\",\n     long_description=\"Python interface to the c++ open quantum system program: DEOM\",\n     install_requires=requirements,\n )\n</code></pre> and a <code>requirements.txt</code> file in this directory <pre><code>cvxopt==1.3.2\nnumpy==1.22.1\npandas==1.5.1\nscipy==1.7.3\nsympy==1.11.1\n</code></pre></p> <p>Seggestions</p> <p>If you don't already use <code>conda</code> to manage python environments, consider give it a try: <pre><code>conda create -n deom python\n\n# when every you want to use this environment \nconda acitvate deom\n</code></pre></p> <p>Finally, feel free to use this one liner to install the package <pre><code>pip install -e . \n</code></pre></p>"}]}